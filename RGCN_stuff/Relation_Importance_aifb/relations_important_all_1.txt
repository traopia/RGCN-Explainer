    def loss(self, pred, pred_label, node_idx, epoch):
        """
        Args:
            pred: prediction made by current model
            pred_label: the label predicted by the original model.
        """

        # prediction loss
        lambda_reg = self.coeffs["lambda_reg"]
        
        gt_label_node = self.label#[node_idx]
        logit = pred[gt_label_node]
        pred_loss =  -torch.log(logit) * self.coeffs["pred"]

        # size loss
        mask = self.mask
        num_high = len([i for i in mask if i > 0.5])
        if num_high>300:
            lambda_reg = 0.5
        print('num_high', num_high,'len(mask)', len(mask))
        # print('mask', mask)
        #print('gradient of the mask:', mask.grad)  # None at the beginning

        mask = torch.sigmoid(self.mask)  # sigmoid of the mask

        #size_loss = self.coeffs["size"] * torch.sum(mask)
        mask_without_small = mask[mask > 0.5]
        print('mask_without_small', mask_without_small)
        if len(mask_without_small) < len(mask):

            size_loss =  100*self.coeffs["size"] * torch.std(mask_without_small)
            reg_loss = 0.1 * lambda_reg * torch.norm(mask_without_small, p=1)
        else:   
            reg_loss =  lambda_reg * torch.norm(mask_without_small, p=1)
            size_loss = self.coeffs["size"] * torch.std(mask) 
        #size_loss = self.size_loss_f(mask, self.coeffs)


        #size_num_loss = self.coeffs["size_num"] * num_high #(num_high - self.num_nodes / 2) ** 2
        #size_num_loss = self.coeffs["size_num"] * (len(mask) - num_high / 2) ** 2
        #size_num_loss = self.coeffs["size_num"] * (num_high+0.0001)/len(mask) 
        size_num_loss = self.coeffs["size_num"] * num_high#(num_high+0.0001)/len(mask) 





        # entropy edge mask 
        mask_ent = -mask * torch.log(mask) - (1 - mask) * torch.log(1 - mask)
        mask_ent_loss = self.coeffs["ent"] * torch.mean(mask_ent)

        
        if len(mask_without_small) <=3:
            loss = pred_loss
        else:
            loss = pred_loss + size_loss + size_num_loss + mask_ent_loss + reg_loss

        # laplacian loss
        # D = torch.diag(torch.sum(self.masked_adj[0], 0))
        # m_adj = self.masked_adj
        # L = D - m_adj

        # pred_label_t = torch.tensor(pred_label, dtype=torch.float)

        # lap_loss = (self.coeffs["lap"] * (pred_label_t @ L @ pred_label_t) / self.masked_adj())

        #loss = pred_loss + size_loss + size_num_loss# + mask_ent_loss #+ lap_loss  # feat_mask_ent_loss 
        print('pred_loss', pred_loss)
        print('size_loss', size_loss)
        print('size_num_loss', size_num_loss)


        return loss, pred_loss, size_loss, size_num_loss, mask_ent_loss, reg_loss


        self.coeffs = {
            "pred": 10,
            "size": -100,  # 0.005,
            "feat_size": 1.0,
            "ent": 1,
            "feat_ent": 0.1,
            "grad": 1,
            "lap": 1.0, 
            "size_num": 0.1,
            "lr": 0.1,
            "lambda_reg": 0.1}